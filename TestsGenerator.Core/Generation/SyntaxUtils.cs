using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TestsGenerator.Core.Exceptions;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace TestsGenerator.Core.Generation;

internal static class SyntaxUtils
{
    private static NameSyntax GetFullNameFrom(NamespaceDeclarationSyntax @namespace)
    {
        // Collect identifiers of namespaces in reverse order.
        var stack = new Stack<string>();
        for (var current = @namespace; current != null; current = current.Parent as NamespaceDeclarationSyntax)
            stack.Push(current.Name.ToString());

        return ParseName(string.Join(".", stack));
    }

    private static IEnumerable<NameSyntax> GetAllNamespacesFrom(NameSyntax sourceNamespaceName)
    {
        // Outer namespaces first.
        var sourceNamespaceNames = new Stack<NameSyntax>();

        // Get all nested namespaces full names by qualified name syntax.
        var current = sourceNamespaceName;
        while (current is QualifiedNameSyntax complexName)
        {
            sourceNamespaceNames.Push(current);
            current = complexName.Left;
        }

        sourceNamespaceNames.Push(current);

        return sourceNamespaceNames;
    }

    public static BlockSyntax GetFailedTestBlock()
    {
        return Block(
            ExpressionStatement(
                ThrowExpression(
                    ObjectCreationExpression(
                        IdentifierName("NotImplementedException"),
                        ArgumentList(
                            SingletonSeparatedList(
                                Argument(
                                    LiteralExpression(
                                        SyntaxKind.StringLiteralExpression,
                                        Literal("autogenerated"))))),
                        null))));
    }

    public static NameSyntax ExtractSourceNamespaceFullName(ClassDeclarationSyntax sourceClass)
    {
        // Return full name of source class namespace.
        return sourceClass.Parent switch
        {
            // Class can be either in =1 file scoped namespace or in >=1 nested namespaces.
            FileScopedNamespaceDeclarationSyntax fileNamespace => fileNamespace.Name,
            NamespaceDeclarationSyntax @namespace => GetFullNameFrom(@namespace),
            _ => throw new SourceSyntaxException("Source class declaration was not in namespace")
        };
    }

    public static IEnumerable<MethodDeclarationSyntax> GenerateTestsMethods(
        ClassDeclarationSyntax sourceClass,
        Func<MethodDeclarationSyntax, BlockSyntax> generateBody)
    {
        var overloadCounts = new Dictionary<string, int>();
        var testsMethods = new List<MethodDeclarationSyntax>();
        foreach (var sourceMember in sourceClass.Members)
        {
            // Ignore members that are not public methods.
            if (sourceMember is not MethodDeclarationSyntax sourceMethod ||
                !sourceMethod.Modifiers.Any(SyntaxKind.PublicKeyword)) continue;

            // Tests method naming including overloads.
            var sourceMethodName = sourceMethod.Identifier.Text;
            if (!overloadCounts.TryAdd(sourceMethodName, 1))
                overloadCounts[sourceMethodName] += 1;
            var testsMethodName = overloadCounts[sourceMethodName] == 1
                ? sourceMethodName + "Test"
                : sourceMethodName + $"Test_{overloadCounts[sourceMethodName] - 1}";

            // Create method declaration children.
            var attributes = SingletonList(
                AttributeList(
                    SingletonSeparatedList(
                        Attribute(
                            IdentifierName("Fact")))));
            var modifiers = TokenList(Token(SyntaxKind.PublicKeyword));
            var identifier = Identifier(testsMethodName);
            var returnType = PredefinedType(Token(SyntaxKind.VoidKeyword));
            var body = generateBody(sourceMethod);

            // Add method to collection.
            testsMethods.Add(MethodDeclaration(returnType, identifier)
                .WithModifiers(modifiers)
                .WithAttributeLists(attributes)
                .WithBody(body));
        }

        return testsMethods;
    }

    public static ClassDeclarationSyntax GenerateTestsClass(
        IEnumerable<MethodDeclarationSyntax> testsMethods,
        ClassDeclarationSyntax sourceClass)
    {
        var name = sourceClass.Identifier.Text + "Tests";
        var modifiers = TokenList(Token(SyntaxKind.PublicKeyword));
        return ClassDeclaration(name)
            .WithModifiers(modifiers)
            .WithMembers(new SyntaxList<MemberDeclarationSyntax>(testsMethods));
    }

    public static FileScopedNamespaceDeclarationSyntax GenerateTestsNamespace(
        ClassDeclarationSyntax testsClass,
        NameSyntax sourceNamespaceName)
    {
        // Append test postfix to found name.
        var name = QualifiedName(sourceNamespaceName, IdentifierName("Tests"));

        return FileScopedNamespaceDeclaration(name).AddMembers(testsClass);
    }

    private static List<UsingDirectiveSyntax> AddChained(this List<UsingDirectiveSyntax> self,
        UsingDirectiveSyntax item)
    {
        self.Add(item);
        return self;
    }


    private static List<UsingDirectiveSyntax> AddChained(this List<UsingDirectiveSyntax> self,
        IEnumerable<UsingDirectiveSyntax> items)
    {
        self.AddRange(items);
        return self;
    }

    public static SyntaxList<UsingDirectiveSyntax> GenerateTestsUsingDirectives(
        IEnumerable<UsingDirectiveSyntax> sourceUsingDirectives,
        NameSyntax sourceNamespaceName)
    {
        // Redundant using directives for each outer namespace of test class.
        // May be needed in case of renaming test namespace.
        var sourceNamespaces = GetAllNamespacesFrom(sourceNamespaceName);

        // Return list of namespaces.
        return new SyntaxList<UsingDirectiveSyntax>(new List<UsingDirectiveSyntax>()
            .AddChained(UsingDirective(ParseName("System")))
            .AddChained(UsingDirective(ParseName("System.Collections.Generic")))
            .AddChained(UsingDirective(ParseName("System.Linq")))
            .AddChained(UsingDirective(ParseName("System.Text")))
            .AddChained(UsingDirective(ParseName("Xunit")))
            .AddChained(sourceUsingDirectives) // Namespaces from source unit & nested namespaces
            .AddChained(sourceNamespaces.Select(UsingDirective)) // Outer & own namespaces of source class
            .DistinctBy(usingDirective => usingDirective.Name.ToString()));
    }


    public static CompilationUnitSyntax GenerateTestsUnit(
        SyntaxList<UsingDirectiveSyntax> testsUsingDirectives,
        FileScopedNamespaceDeclarationSyntax testsNamespace)
    {
        return CompilationUnit()
            .WithUsings(testsUsingDirectives)
            .WithMembers(new SyntaxList<MemberDeclarationSyntax>(testsNamespace));
    }
}