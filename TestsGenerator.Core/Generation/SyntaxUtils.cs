using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TestsGenerator.Core.Exceptions;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace TestsGenerator.Core.Generation;

internal static class SyntaxUtils
{
    private static NameSyntax GetFullNameFrom(NamespaceDeclarationSyntax @namespace)
    {
        // Collect identifiers of namespaces in reverse order
        var stack = new Stack<string>();
        for (var current = @namespace; current != null; current = current.Parent as NamespaceDeclarationSyntax)
            stack.Push(current.Name.ToString());

        return ParseName(string.Join(".", stack));
    }
    
    private static IEnumerable<NameSyntax> GetAllNamespacesFrom(NameSyntax sourceNamespaceName)
    {
        // Outer namespaces first
        var sourceNamespaceNames = new Stack<NameSyntax>();

        // Get all nested namespaces full names by qualified name syntax 
        var current = sourceNamespaceName;
        while (current is QualifiedNameSyntax complexName)
        {
            sourceNamespaceNames.Push(current);
            current = complexName.Left;
        }

        sourceNamespaceNames.Push(current);

        return sourceNamespaceNames;
    }

    public static SyntaxList<UsingDirectiveSyntax> GenerateTestsUsingDirectives(
        IEnumerable<UsingDirectiveSyntax> sourceUsingDirectives,
        NameSyntax sourceNamespaceName)
    {
        var sourceNamespaces = GetAllNamespacesFrom(sourceNamespaceName);

        // Return list of namespaces
        return new SyntaxList<UsingDirectiveSyntax>()
            .Add(UsingDirective(ParseName("System")))
            .Add(UsingDirective(ParseName("System.Collections.Generic")))
            .Add(UsingDirective(ParseName("System.Linq")))
            .Add(UsingDirective(ParseName("System.Text")))
            .Add(UsingDirective(ParseName("XUnit")))
            .AddRange(sourceUsingDirectives) // Namespaces from source unit & nested namespaces
            .AddRange(sourceNamespaces.Select(UsingDirective)); // Outer & own namespaces of source class;
    }

    public static FileScopedNamespaceDeclarationSyntax GenerateTestsNamespace(
        ClassDeclarationSyntax testsClass,
        NameSyntax sourceNamespaceName)
    {
        // Append test postfix to found name
        var name = QualifiedName(sourceNamespaceName, IdentifierName("Tests"));

        return FileScopedNamespaceDeclaration(name).AddMembers(testsClass);
    }
    
    public static NameSyntax ExtractSourceNamespaceFullName(ClassDeclarationSyntax sourceClass)
    {
        // Return full name of source class namespace
        return sourceClass.Parent switch
        {
            // Class can be either in =1 file scoped namespace or in >=1 nested namespaces
            FileScopedNamespaceDeclarationSyntax fileNamespace => fileNamespace.Name,
            NamespaceDeclarationSyntax @namespace => GetFullNameFrom(@namespace),
            _ => throw new SyntaxException("Source class was not in namespace")
        };
    }

    public static MethodDeclarationSyntax[] GenerateTestsMethods(ClassDeclarationSyntax sourceClass)
    {
        return (from sourceMember in sourceClass.Members
                let sourceMethod = sourceMember as MethodDeclarationSyntax
                where sourceMethod != null && sourceMethod.Modifiers.Any(SyntaxKind.PublicKeyword)
                let attributes = SingletonList(
                    AttributeList(
                        SingletonSeparatedList(
                            Attribute(
                                IdentifierName("Fact")))))
                let modifiers = TokenList(Token(SyntaxKind.PublicKeyword))
                let identifier = Identifier(sourceMethod.Identifier.Text + "Test")
                let returnType = PredefinedType(Token(SyntaxKind.VoidKeyword))
                let body = Block(
                    ExpressionStatement(
                        InvocationExpression(
                            MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                                IdentifierName(
                                    Identifier("Assert")),
                                IdentifierName("Fail")),
                            ArgumentList(
                                SingletonSeparatedList(
                                    Argument(
                                        LiteralExpression(
                                            SyntaxKind.StringLiteralExpression,
                                            Literal("autogenerated"))))))))
                select MethodDeclaration(returnType, identifier)
                    .WithModifiers(modifiers)
                    .WithAttributeLists(attributes)
                    .WithBody(body))
            .ToArray();
    }

    public static ClassDeclarationSyntax GenerateTestsClass(
        MethodDeclarationSyntax[] testsMethods,
        ClassDeclarationSyntax sourceClass)
    {
        var name = sourceClass.Identifier.Text + "Tests";
        var modifiers = TokenList(Token(SyntaxKind.PublicKeyword));
        return ClassDeclaration(name)
            .WithModifiers(modifiers)
            // ReSharper disable once CoVariantArrayConversion
            .AddMembers(testsMethods);
    }

    public static CompilationUnitSyntax GenerateTestsUnit(SyntaxList<UsingDirectiveSyntax> testsUsingDirectives,
        FileScopedNamespaceDeclarationSyntax testsNamespace)
    {
        return CompilationUnit()
            .WithUsings(testsUsingDirectives)
            .WithMembers(new SyntaxList<MemberDeclarationSyntax>(testsNamespace));
    }
}