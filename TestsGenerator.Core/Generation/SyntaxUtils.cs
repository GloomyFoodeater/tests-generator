using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TestsGenerator.Core.Exceptions;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace TestsGenerator.Core.Generation;

internal static class SyntaxUtils
{
    private static List<T> AddChained<T>(this List<T> self, T item)
    {
        self.Add(item);
        return self;
    }

    private static List<T> AddChained<T>(this List<T> self, IEnumerable<T> items)
    {
        self.AddRange(items);
        return self;
    }

    private static string GetFullNameOf(NamespaceDeclarationSyntax nestedNamespace)
    {
        // Collect identifiers of namespaces in reverse order.
        var stack = new Stack<string>();
        var current = nestedNamespace;
        while (current != null)
        {
            stack.Push(current.Name.ToString());
            current = current.Parent as NamespaceDeclarationSyntax;
        }

        return string.Join(".", stack);
    }

    public static string[] GetFullNamespacesNamesFrom(ClassDeclarationSyntax sourceClass)
    {
        var fullInnerName = sourceClass.Parent switch
        {
            NamespaceDeclarationSyntax nestedNamespace => GetFullNameOf(nestedNamespace),
            FileScopedNamespaceDeclarationSyntax fileScopedNamespace => fileScopedNamespace.Name.ToString(),
            _ => throw new TestsGeneratorException("Source class declaration was not in namespace")
        };

        // Re-splitting for nested namespaces is necessary,
        // since namespace declaration can contain QualifiedNameSyntax.
        var simpleNames = fullInnerName.Split(".");

        // Join simple names in full namespace names by previous name.
        var fullNames = new string[simpleNames.Length];
        fullNames[0] = simpleNames[0];
        for (var i = 1; i < simpleNames.Length; i++)
            fullNames[i] = $"{fullNames[i - 1]}.{simpleNames[i]}";
        return fullNames;
    }
    
    public static BlockSyntax GetFailedTestBlock()
    {
        // Syntax of: throw new NotImplementedException("Autogenerated");
        return Block(
            ExpressionStatement(
                ThrowExpression(
                    ObjectCreationExpression(
                        IdentifierName("NotImplementedException"),
                        ArgumentList(
                            SingletonSeparatedList(
                                Argument(
                                    LiteralExpression(
                                        SyntaxKind.StringLiteralExpression,
                                        Literal("Autogenerated"))))),
                        null))));
    }

    public static BlockSyntax GetTemplateTestBlock(MethodDeclarationSyntax sourceMethod)
    {
        // Parts of the block.
        var arrangePart = new List<StatementSyntax>();
        StatementSyntax actPart;
        var assertPart = new List<StatementSyntax>();

        // Comma-separated argument list of method invocation.
        var separatedArguments = new List<SyntaxNodeOrToken>();

        // Iterate over parameters to create arrange part and argument list of act part.
        foreach (var parameter in sourceMethod.ParameterList.Parameters)
        {
            var declaration = LocalDeclarationStatement(
                VariableDeclaration(parameter.Type!)
                    .WithVariables(
                        SingletonSeparatedList(
                            VariableDeclarator(parameter.Identifier.Text)
                                .WithInitializer(
                                    EqualsValueClause(
                                        LiteralExpression(
                                            SyntaxKind.DefaultLiteralExpression,
                                            Token(SyntaxKind.DefaultKeyword)))))));
            separatedArguments.Add(Argument(IdentifierName(parameter.Identifier.Text)));
            separatedArguments.Add(Token(SyntaxKind.CommaToken));
            arrangePart.Add(declaration);
        }

        if (separatedArguments.Any())
            separatedArguments.RemoveAt(separatedArguments.Count - 1);

        // Create invocation of source method in act part.
        var methodInvocation = InvocationExpression(
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName((sourceMethod.Parent as ClassDeclarationSyntax)!.Identifier.Text),
                    IdentifierName(sourceMethod.Identifier.Text)))
            .WithArgumentList(
                ArgumentList(
                    SeparatedList<ArgumentSyntax>(
                        separatedArguments.ToArray())));

        // Create act part and add comparison with expected value in assert part.
        if (sourceMethod.ReturnType.Kind() == SyntaxKind.VoidKeyword)
        {
            // Invoke method.
            actPart = ExpressionStatement(methodInvocation);
        }
        else
        {
            // Assign to variable <actual> invocation statement.
            actPart = LocalDeclarationStatement(
                VariableDeclaration(sourceMethod.ReturnType)
                    .WithVariables(
                        SingletonSeparatedList(
                            VariableDeclarator(
                                    Identifier("actual"))
                                .WithInitializer(
                                    EqualsValueClause(methodInvocation)))));

            // Declare variable <expected> and assert it equality with variable <actual>.
            assertPart
                .AddChained(LocalDeclarationStatement(
                    VariableDeclaration(sourceMethod.ReturnType)
                        .WithVariables(
                            SingletonSeparatedList(
                                VariableDeclarator(
                                        Identifier("expected"))
                                    .WithInitializer(
                                        EqualsValueClause(
                                            LiteralExpression(
                                                SyntaxKind.DefaultLiteralExpression,
                                                Token(SyntaxKind.DefaultKeyword))))))))
                .AddChained(ExpressionStatement(
                    InvocationExpression(
                            MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                IdentifierName("Assert"),
                                IdentifierName("Equal")))
                        .WithArgumentList(
                            ArgumentList(
                                SeparatedList<ArgumentSyntax>(
                                    new SyntaxNodeOrToken[]
                                    {
                                        Argument(
                                            IdentifierName("expected")),
                                        Token(SyntaxKind.CommaToken),
                                        Argument(
                                            IdentifierName("actual"))
                                    })))));
        }

        // Throw exception.
        assertPart.Add(ExpressionStatement(
            ThrowExpression(
                ObjectCreationExpression(
                    IdentifierName("NotImplementedException"),
                    ArgumentList(
                        SingletonSeparatedList(
                            Argument(
                                LiteralExpression(
                                    SyntaxKind.StringLiteralExpression,
                                    Literal("Autogenerated"))))),
                    null))));

        return Block(new List<StatementSyntax>()
            .AddChained(arrangePart)
            .AddChained(actPart)
            .AddChained(assertPart));
    }

    public static IEnumerable<MethodDeclarationSyntax> GenerateTestsMethods(
        ClassDeclarationSyntax sourceClass,
        Func<MethodDeclarationSyntax, BlockSyntax> generateBody)
    {
        var overloadCounts = new Dictionary<string, int>(); // Counters of each method overloads
        var testsMethods = new List<MethodDeclarationSyntax>();
        foreach (var sourceMember in sourceClass.Members)
        {
            // Ignore members that are not public methods.
            if (sourceMember is not MethodDeclarationSyntax sourceMethod ||
                !sourceMethod.Modifiers.Any(SyntaxKind.PublicKeyword)) continue;

            // Tests method naming including overloads.
            var sourceMethodName = sourceMethod.Identifier.Text;
            if (!overloadCounts.TryAdd(sourceMethodName, 1))
                overloadCounts[sourceMethodName] += 1;
            var testsMethodName = overloadCounts[sourceMethodName] == 1
                ? sourceMethodName + "Test"
                : sourceMethodName + $"Test_{overloadCounts[sourceMethodName] - 1}";

            // Create method declaration children.
            var attributes = SingletonList(
                AttributeList(
                    SingletonSeparatedList(
                        Attribute(
                            IdentifierName("Fact")))));
            var modifiers = TokenList(Token(SyntaxKind.PublicKeyword));
            var identifier = Identifier(testsMethodName);
            var returnType = PredefinedType(Token(SyntaxKind.VoidKeyword));
            var body = generateBody(sourceMethod);

            // Add method to collection.
            testsMethods.Add(
                MethodDeclaration(returnType, identifier)
                    .WithModifiers(modifiers)
                    .WithAttributeLists(attributes)
                    .WithBody(body));
        }

        return testsMethods;
    }

    public static ClassDeclarationSyntax GenerateTestsClass(
        IEnumerable<MethodDeclarationSyntax> testsMethods,
        ClassDeclarationSyntax sourceClass)
    {
        var name = sourceClass.Identifier.Text + "Tests";
        var modifiers = TokenList(Token(SyntaxKind.PublicKeyword));
        return ClassDeclaration(name)
            .WithModifiers(modifiers)
            .WithMembers(new SyntaxList<MemberDeclarationSyntax>(testsMethods));
    }

    public static FileScopedNamespaceDeclarationSyntax GenerateTestsNamespace(
        ClassDeclarationSyntax testsClass,
        IEnumerable<string> sourceNamespacesNames)
    {
        // Append test postfix to the first (solution) name.
        var name = QualifiedName(
            IdentifierName(sourceNamespacesNames.First()),
            IdentifierName("Tests"));

        return FileScopedNamespaceDeclaration(name).AddMembers(testsClass);
    }

    public static SyntaxList<UsingDirectiveSyntax> GenerateTestsUsingDirectives(
        IEnumerable<UsingDirectiveSyntax> sourceUsingDirectives,
        IEnumerable<string> sourceNamespacesNames)
    {
        // Return list of namespaces.
        return new SyntaxList<UsingDirectiveSyntax>(new List<UsingDirectiveSyntax>()
            .AddChained(UsingDirective(ParseName("System")))
            .AddChained(UsingDirective(ParseName("System.Collections.Generic")))
            .AddChained(UsingDirective(ParseName("System.Linq")))
            .AddChained(UsingDirective(ParseName("System.Text")))
            .AddChained(UsingDirective(ParseName("Xunit")))
            .AddChained(sourceUsingDirectives) // Namespaces from source unit & nested namespaces
            .AddChained(sourceNamespacesNames
                .Skip(1) // Tests namespace is inside of 1st source namespace 
                .Select(name => UsingDirective(ParseName(name)))) // Outer & own namespaces of source class
            .DistinctBy(usingDirective => usingDirective.Name.ToString()));
    }

    public static CompilationUnitSyntax GenerateTestsUnit(
        SyntaxList<UsingDirectiveSyntax> testsUsingDirectives,
        FileScopedNamespaceDeclarationSyntax testsNamespace)
    {
        return CompilationUnit()
            .WithUsings(testsUsingDirectives)
            .WithMembers(new SyntaxList<MemberDeclarationSyntax>(testsNamespace));
    }
}