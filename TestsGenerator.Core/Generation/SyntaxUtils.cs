using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using TestsGenerator.Core.Exceptions;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace TestsGenerator.Core.Generation;

internal static class SyntaxUtils
{
    private static string GetFullNameOf(NamespaceDeclarationSyntax nestedNamespace)
    {
        // Collect identifiers of namespaces in reverse order.
        var stack = new Stack<string>();
        var current = nestedNamespace;
        while (current != null)
        {
            stack.Push(current.Name.ToString());
            current = current.Parent as NamespaceDeclarationSyntax;
        }

        return string.Join(".", stack);
    }

    public static IEnumerable<string> GetFullNamespacesNamesFrom(ClassDeclarationSyntax sourceClass)
    {
        var fullInnerName = sourceClass.Parent switch
        {
            NamespaceDeclarationSyntax nestedNamespace => GetFullNameOf(nestedNamespace),
            FileScopedNamespaceDeclarationSyntax fileScopedNamespace => fileScopedNamespace.Name.ToString(),
            _ => throw new SourceSyntaxException("Source class declaration was not in namespace")
        };

        // Re-splitting for nested namespaces is necessary,
        // since namespace declaration can contain QualifiedNameSyntax.
        var simpleNames = fullInnerName.Split(".");

        // Join simple names in full namespace names by previous name.
        var fullNames = new string[simpleNames.Length];
        fullNames[0] = simpleNames[0];
        for (var i = 1; i < simpleNames.Length; i++)
            fullNames[i] = $"{fullNames[i - 1]}.{simpleNames[i]}";
        return fullNames;
    }

    public static BlockSyntax GetFailedTestBlock()
    {
        // Syntax of: throw new NotImplementedException("Autogenerated");
        return Block(
            ExpressionStatement(
                ThrowExpression(
                    ObjectCreationExpression(
                        IdentifierName("NotImplementedException"),
                        ArgumentList(
                            SingletonSeparatedList(
                                Argument(
                                    LiteralExpression(
                                        SyntaxKind.StringLiteralExpression,
                                        Literal("Autogenerated"))))),
                        null))));
    }

    public static IEnumerable<MethodDeclarationSyntax> GenerateTestsMethods(
        ClassDeclarationSyntax sourceClass,
        Func<MethodDeclarationSyntax, BlockSyntax> generateBody)
    {
        var overloadCounts = new Dictionary<string, int>(); // Counters of each method overloads
        var testsMethods = new List<MethodDeclarationSyntax>();
        foreach (var sourceMember in sourceClass.Members)
        {
            // Ignore members that are not public methods.
            if (sourceMember is not MethodDeclarationSyntax sourceMethod ||
                !sourceMethod.Modifiers.Any(SyntaxKind.PublicKeyword)) continue;

            // Tests method naming including overloads.
            var sourceMethodName = sourceMethod.Identifier.Text;
            if (!overloadCounts.TryAdd(sourceMethodName, 1))
                overloadCounts[sourceMethodName] += 1;
            var testsMethodName = overloadCounts[sourceMethodName] == 1
                ? sourceMethodName + "Test"
                : sourceMethodName + $"Test_{overloadCounts[sourceMethodName] - 1}";

            // Create method declaration children.
            var attributes = SingletonList(
                AttributeList(
                    SingletonSeparatedList(
                        Attribute(
                            IdentifierName("Fact")))));
            var modifiers = TokenList(Token(SyntaxKind.PublicKeyword));
            var identifier = Identifier(testsMethodName);
            var returnType = PredefinedType(Token(SyntaxKind.VoidKeyword));
            var body = generateBody(sourceMethod);

            // Add method to collection.
            testsMethods.Add(
                MethodDeclaration(returnType, identifier)
                    .WithModifiers(modifiers)
                    .WithAttributeLists(attributes)
                    .WithBody(body));
        }

        return testsMethods;
    }

    public static ClassDeclarationSyntax GenerateTestsClass(
        IEnumerable<MethodDeclarationSyntax> testsMethods,
        ClassDeclarationSyntax sourceClass)
    {
        var name = sourceClass.Identifier.Text + "Tests";
        var modifiers = TokenList(Token(SyntaxKind.PublicKeyword));
        return ClassDeclaration(name)
            .WithModifiers(modifiers)
            .WithMembers(new SyntaxList<MemberDeclarationSyntax>(testsMethods));
    }

    public static FileScopedNamespaceDeclarationSyntax GenerateTestsNamespace(
        ClassDeclarationSyntax testsClass,
        IEnumerable<string> sourceNamespacesNames)
    {
        // Append test postfix to the first (solution) name.
        var name = QualifiedName(
            IdentifierName(sourceNamespacesNames.First()),
            IdentifierName("Tests"));

        return FileScopedNamespaceDeclaration(name).AddMembers(testsClass);
    }

    private static List<UsingDirectiveSyntax> AddChained(this List<UsingDirectiveSyntax> self,
        UsingDirectiveSyntax item)
    {
        self.Add(item);
        return self;
    }


    private static List<UsingDirectiveSyntax> AddChained(this List<UsingDirectiveSyntax> self,
        IEnumerable<UsingDirectiveSyntax> items)
    {
        self.AddRange(items);
        return self;
    }

    public static SyntaxList<UsingDirectiveSyntax> GenerateTestsUsingDirectives(
        IEnumerable<UsingDirectiveSyntax> sourceUsingDirectives,
        IEnumerable<string> sourceNamespacesNames)
    {
        // Return list of namespaces.
        return new SyntaxList<UsingDirectiveSyntax>(new List<UsingDirectiveSyntax>()
            .AddChained(UsingDirective(ParseName("System")))
            .AddChained(UsingDirective(ParseName("System.Collections.Generic")))
            .AddChained(UsingDirective(ParseName("System.Linq")))
            .AddChained(UsingDirective(ParseName("System.Text")))
            .AddChained(UsingDirective(ParseName("Xunit")))
            .AddChained(sourceUsingDirectives) // Namespaces from source unit & nested namespaces
            .AddChained(sourceNamespacesNames
                .Skip(1) // Tests namespace is inside of 1st source namespace 
                .Select(name => UsingDirective(ParseName(name)))) // Outer & own namespaces of source class
            .DistinctBy(usingDirective => usingDirective.Name.ToString()));
    }

    public static CompilationUnitSyntax GenerateTestsUnit(
        SyntaxList<UsingDirectiveSyntax> testsUsingDirectives,
        FileScopedNamespaceDeclarationSyntax testsNamespace)
    {
        return CompilationUnit()
            .WithUsings(testsUsingDirectives)
            .WithMembers(new SyntaxList<MemberDeclarationSyntax>(testsNamespace));
    }
}